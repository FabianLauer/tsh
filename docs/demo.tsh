class RequireConfigPaths {
	const vs = "monaco-editor/vs"
}

class RequireConfig {
	const paths = RequireConfigPaths()
}

/// The main function of the demo.
func main() -> Void {
	require.config(RequireConfig())
	require(window.createJSArray('vs/editor/editor.main'), func () {
		startDemo(monaco)
	})
}


func startDemo(monaco: Any) -> Void {
	const sourceEditor = createEditor(monaco, "source-container", "swift", false, getSampleCode())

	const compiledEditor = createEditor(monaco, "compiled-container", "javascript", true, "")

	const recompile = func() {
		compile(sourceEditor, compiledEditor)
	}

	// compile once on start
	recompile()

	// bind events
	sourceEditor.onDidType(recompile)
	sourceEditor.onDidPaste(recompile)
	sourceEditor.onDidBlurEditor(recompile)
	sourceEditor.onDidChangeModelContent(recompile)
}


class MonacoEditorOptions {
	let value: String
	let language: String
	let readOnly: Bool

	const lineNumbers = true
	const roundedSelection = false
	const scrollBeyondLastLine = true
	const theme = "vs-light"
	const fontSize = 11
	const wordWrap = true
	const folding = true
}


func createEditor(monaco: Any, containerId: String, language: String, readOnly: Bool, content: String) -> Any {
	const options = MonacoEditorOptions()

	options.value = content
	options.language = language
	options.readOnly = readOnly

	return monaco.editor.create(document.getElementById(containerId), options)
}

enum CompileTarget {
	JavaScript,
	TypeScriptDeclaration
}


func compile(sourceEditor: Any, compiledEditor: Any) -> Void {
	clearCompileProblems()

	let sourceCode = sourceEditor.getValue()
	let code = ""
	let compiled = false
	let compiledCode

	// compile to JavaScript
	try {
		compiledCode = compileToTarget(sourceCode, CompileTarget.JavaScript)
		compiled = true
	} catch as err {
		renderCompileProblem(err)
	}
	if compiled {
		code += compiledCode
	}

	// compile to TypeScript declarations
	try {
		compiledCode = compileToTarget(sourceCode, CompileTarget.TypeScriptDeclaration)
		compiled = true
	} catch {
		compiled = false
	}
	if compiled {
		code += compiledCode.replace(_new(RegExp, "\t+", "g"), "  ")

		code += "\n/* --- TypeScript Declarations --- */\n"
		code += "/*\n\n" + compiledCode + "\n*/"
	}

	compiledEditor.setValue(tryBeautifyJavaScript(code))
}


func compileToTarget(sourceCode: String, compileTarget: CompileTarget) -> Void {
	const api = compiler.CompilerApi.create()
	let target: Int

	if compileTarget == CompileTarget.JavaScript {
		target = 0
	} else {
		target = 1
	}

	return api.compileSourceCode(sourceCode, target)
}


func tryBeautifyJavaScript(jsCode) -> String {
	try {
		return window.js_beautify(jsCode)
	} catch {
		return jsCode
	}
}


func getProblemsPanelContentElement() -> HTMLElement {
	return document.getElementById("problems-panel-content")
}


func clearCompileProblems() -> Void {
	const problemsPanelContent = getProblemsPanelContentElement()
	problemsPanelContent.innerHTML = ""
	const content = document.createElement("span")
	content.innerText = "No problems."
	problemsPanelContent.appendChild(content)
}


func renderCompileProblem(error) -> Void {
	const problemsPanelContent = getProblemsPanelContentElement()
	problemsPanelContent.innerHTML = ""
	let problem = document.createElement("pre")
	problem.innerText = error.message
	problemsPanelContent.appendChild(problem)
}
